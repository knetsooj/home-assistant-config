"use strict";
// tslint:disable: no-console
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyCertificateChain = exports.verifyCertificateRevocationListSignature = exports.verifyCertificateSignature = exports.verifyCertificateOrClrSignature = void 0;
// Now that we got a hash of the original certificate,
// we need to verify if we can obtain the same hash by using the same hashing function
// (in this case SHA-384). In order to do that, we need to extract just the body of
// the signed certificate. Which, in our case, is everything but the signature.
// The start of the body is always the first digit of the second line of the following command:
const crypto = require("crypto");
const crypto_explore_certificate_1 = require("./crypto_explore_certificate");
const crypto_utils_1 = require("./crypto_utils");
const asn1_1 = require("./asn1");
function verifyCertificateOrClrSignature(certificateOrCrl, parentCertificate) {
    const block_info = asn1_1.readTag(certificateOrCrl, 0);
    const blocks = asn1_1._readStruct(certificateOrCrl, block_info);
    const bufferToBeSigned = certificateOrCrl.slice(block_info.position, blocks[1].position - 2);
    //xx console.log("bufferToBeSigned  = ", bufferToBeSigned.length, bufferToBeSigned.toString("hex").substr(0, 50), bufferToBeSigned.toString("hex").substr(-10));
    const signatureAlgorithm = asn1_1._readAlgorithmIdentifier(certificateOrCrl, blocks[1]);
    const signatureValue = asn1_1._readSignatureValueBin(certificateOrCrl, blocks[2]);
    const p = crypto_explore_certificate_1.split_der(parentCertificate)[0];
    //xx    const publicKey = extractPublicKeyFromCertificateSync(p);
    const certPem = crypto_utils_1.toPem(p, "CERTIFICATE");
    const verify = crypto.createVerify(signatureAlgorithm.identifier);
    verify.update(bufferToBeSigned);
    verify.end();
    return verify.verify(certPem, signatureValue);
}
exports.verifyCertificateOrClrSignature = verifyCertificateOrClrSignature;
function verifyCertificateSignature(certificate, parentCertificate) {
    return verifyCertificateOrClrSignature(certificate, parentCertificate);
}
exports.verifyCertificateSignature = verifyCertificateSignature;
function verifyCertificateRevocationListSignature(certificateRevocationList, parentCertificate) {
    return verifyCertificateOrClrSignature(certificateRevocationList, parentCertificate);
}
exports.verifyCertificateRevocationListSignature = verifyCertificateRevocationListSignature;
function verifyCertificateChain(certificateChain) {
    return __awaiter(this, void 0, void 0, function* () {
        // verify that all the certificate
        // second certificate must be used for CertificateSign
        for (let index = 1; index < certificateChain.length; index++) {
            const cert = certificateChain[index - 1];
            const certParent = certificateChain[index];
            // parent child must have keyCertSign
            const certParentInfo = crypto_explore_certificate_1.exploreCertificate(certParent);
            const keyUsage = certParentInfo.tbsCertificate.extensions.keyUsage;
            // istanbul ignore next
            if (!keyUsage.keyCertSign) {
                return {
                    status: "BadCertificateIssuerUseNotAllowed",
                    reason: "One of the certificate in the chain has not keyUsage set for Certificate Signing",
                };
            }
            const parentSignChild = verifyCertificateSignature(cert, certParent);
            if (!parentSignChild) {
                return {
                    status: "BadCertificateInvalid",
                    reason: "One of the certificate in the chain is not signing the previous certificate",
                };
            }
            const certInfo = crypto_explore_certificate_1.exploreCertificate(cert);
            // istanbul ignore next
            if (!certInfo.tbsCertificate.extensions) {
                return {
                    status: "BadCertificateInvalid",
                    reason: "Cannot find X409 Extension 3 in certificate",
                };
            }
            // istanbul ignore next
            if (!certParentInfo.tbsCertificate.extensions || !certInfo.tbsCertificate.extensions.authorityKeyIdentifier) {
                return {
                    status: "BadCertificateInvalid",
                    reason: "Cannot find X409 Extension 3 in certificate (parent)",
                };
            }
            // istanbul ignore next
            if (certParentInfo.tbsCertificate.extensions.subjectKeyIdentifier !==
                certInfo.tbsCertificate.extensions.authorityKeyIdentifier.keyIdentifier) {
                return {
                    status: "BadCertificateInvalid",
                    reason: "subjectKeyIdentifier authorityKeyIdentifier in child certificate do not match subjectKeyIdentifier of parent certificate",
                };
            }
        }
        return {
            status: "Good",
            reason: `certificate chain is valid(length = ${certificateChain.length})`,
        };
    });
}
exports.verifyCertificateChain = verifyCertificateChain;
//# sourceMappingURL=verify_certificate_signature.js.map