"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkCertificateValidity = exports.OPCUACertificateManager = void 0;
/**
 * @module node-opcua-certificate-manager
 */
// tslint:disable:no-empty
const chalk = require("chalk");
const fs = require("fs");
const mkdirp = require("mkdirp");
const env_paths_1 = require("env-paths");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const node_opcua_pki_1 = require("node-opcua-pki");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const paths = env_paths_1.default("node-opcua");
const debugLog = node_opcua_debug_1.make_debugLog(__filename);
const errorLog = node_opcua_debug_1.make_errorLog(__filename);
const doDebug = node_opcua_debug_1.checkDebugFlag(__filename);
class OPCUACertificateManager extends node_opcua_pki_1.CertificateManager {
    /* */
    constructor(options) {
        options = options || {};
        const location = options.rootFolder || paths.config;
        if (!fs.existsSync(location)) {
            mkdirp.sync(location);
        }
        const _options = {
            keySize: 2048,
            location
        };
        super(_options);
        this.automaticallyAcceptUnknownCertificate = !!options.automaticallyAcceptUnknownCertificate;
    }
    checkCertificate(certificate, callback) {
        super.verifyCertificate(certificate, (err1, status) => {
            if (err1) {
                return callback(err1);
            }
            const statusCode = node_opcua_status_code_1.StatusCodes[status];
            debugLog("checkCertificate => StatusCode = ", statusCode.toString());
            if (statusCode === node_opcua_status_code_1.StatusCodes.BadCertificateUntrusted) {
                const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate).toString("hex");
                if (this.automaticallyAcceptUnknownCertificate) {
                    debugLog("automaticallyAcceptUnknownCertificate = true");
                    debugLog("certificate with thumbprint " + thumbprint + " is now trusted");
                    return this.trustCertificate(certificate, () => callback(null, node_opcua_status_code_1.StatusCodes.Good));
                }
                else {
                    debugLog("automaticallyAcceptUnknownCertificate = false");
                    debugLog("certificate with thumbprint " + thumbprint + " is now rejected");
                    return this.rejectCertificate(certificate, () => callback(null, node_opcua_status_code_1.StatusCodes.BadCertificateUntrusted));
                }
            }
            // if (!statusCode) {
            //     return callback!(new Error("Invalid statusCode " + status));
            // }
            callback(null, statusCode);
        });
    }
    getTrustStatus(certificate, callback) {
        this.isCertificateTrusted(certificate, (err, trustedStatus) => {
            callback(err, err ? undefined : node_opcua_status_code_1.StatusCodes[trustedStatus]);
        });
    }
}
exports.OPCUACertificateManager = OPCUACertificateManager;
// tslint:disable:no-var-requires
// tslint:disable:max-line-length
const thenify = require("thenify");
const opts = { multiArgs: false };
OPCUACertificateManager.prototype.checkCertificate = thenify.withCallback(OPCUACertificateManager.prototype.checkCertificate, opts);
OPCUACertificateManager.prototype.getTrustStatus = thenify.withCallback(OPCUACertificateManager.prototype.getTrustStatus, opts);
// also see OPCUA 1.02 part 4 :
//  - page 95  6.1.3 Determining if a Certificate is Trusted
// -  page 100 6.2.3 Validating a Software Certificate
//
function checkCertificateValidity(certificate) {
    // Is the  signature on the SoftwareCertificate valid .?
    if (!certificate) {
        // missing certificate
        return node_opcua_status_code_1.StatusCodes.BadSecurityChecksFailed;
    }
    // Has SoftwareCertificate passed its issue date and has it not expired ?
    // check dates
    const cert = node_opcua_crypto_1.exploreCertificateInfo(certificate);
    const now = new Date();
    if (cert.notBefore.getTime() > now.getTime()) {
        // certificate is not active yet
        // tslint:disable-next-line:no-console
        console.log(chalk.red(" Sender certificate is invalid : certificate is not active yet !") + "  not before date =" + cert.notBefore);
        return node_opcua_status_code_1.StatusCodes.BadCertificateTimeInvalid;
    }
    if (cert.notAfter.getTime() <= now.getTime()) {
        // certificate is obsolete
        // tslint:disable-next-line:no-console
        console.log(chalk.red(" Sender certificate is invalid : certificate has expired !") + " not after date =" + cert.notAfter);
        return node_opcua_status_code_1.StatusCodes.BadCertificateTimeInvalid;
    }
    // Has SoftwareCertificate has  been revoked by the issuer ?
    // TODO: check if certificate is revoked or not ...
    // StatusCodes.BadCertificateRevoked
    // is issuer Certificate  valid and has not been revoked by the CA that issued it. ?
    // TODO : check validity of issuer certificate
    // StatusCodes.BadCertificateIssuerRevoked
    // does the URI specified in the ApplicationDescription  match the URI in the Certificate ?
    // TODO : check ApplicationDescription of issuer certificate
    // return StatusCodes.BadCertificateUriInvalid
    return node_opcua_status_code_1.StatusCodes.Good;
}
exports.checkCertificateValidity = checkCertificateValidity;
//# sourceMappingURL=certificate_manager.js.map