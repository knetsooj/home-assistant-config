"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeIdManager = exports.NamespaceOptions = void 0;
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
exports.NamespaceOptions = {
    nodeIdNameSeparator: "-"
};
function isValidNodeClass(nodeClass) {
    return typeof node_opcua_data_model_1.NodeClass[nodeClass] === "string";
}
const regExp1 = /^(s|i|b|g)=/;
const regExp2 = /^ns=[0-9]+;(s|i|b|g)=/;
const hasPropertyRefId = node_opcua_nodeid_1.resolveNodeId("HasProperty");
const hasComponentRefId = node_opcua_nodeid_1.resolveNodeId("HasComponent");
const hasEncoding = node_opcua_nodeid_1.resolveNodeId("HasEncoding");
function _identifyParentInReference(references) {
    const candidates = references.filter((r) => {
        return (!r.isForward &&
            (node_opcua_nodeid_1.sameNodeId(r.referenceType, hasComponentRefId) ||
                node_opcua_nodeid_1.sameNodeId(r.referenceType, hasPropertyRefId) ||
                node_opcua_nodeid_1.sameNodeId(r.referenceType, hasEncoding)));
    });
    node_opcua_assert_1.assert(candidates.length <= 1);
    if (candidates.length === 0) {
        return null;
    }
    const ref = candidates[0];
    if (node_opcua_nodeid_1.sameNodeId(ref.referenceType, hasEncoding)) {
        return [ref.nodeId, "_Encoding"];
    }
    return [ref.nodeId, ""];
}
class NodeIdManager {
    constructor(namespaceIndex, addressSpace) {
        this._cache = {};
        this._reverseCache = {};
        this._internal_id_counter = 1000;
        this.namespaceIndex = namespaceIndex;
        this.addressSpace = addressSpace;
    }
    setCache(cache) {
        this._cache = {};
        this._reverseCache = {};
        for (const [key, value, nodeClass] of cache) {
            this._addInCache(key, value, nodeClass);
        }
    }
    setSymbols(symbols) {
        function convertNodeClass(nodeClass) {
            return node_opcua_data_model_1.NodeClass[nodeClass];
        }
        const symbols2 = symbols.map((e) => [e[0], e[1], convertNodeClass(e[2])]);
        this.setCache(symbols2);
    }
    getSymbols() {
        const line = [];
        for (const [key, value] of Object.entries(this._cache)) {
            const nodeClass = node_opcua_data_model_1.NodeClass[this._reverseCache[value].nodeClass];
            line.push([key, value, nodeClass]);
        }
        return line;
    }
    getSymbolCSV() {
        const line = [];
        for (const [name, value, nodeClass] of this.getSymbols()) {
            line.push([name, value, nodeClass].join(";"));
        }
        return line.join("\n");
    }
    buildNewNodeId() {
        let nodeId;
        do {
            nodeId = node_opcua_nodeid_1.makeNodeId(this._internal_id_counter, this.namespaceIndex);
            this._internal_id_counter += 1;
        } while (this.addressSpace.findNode(nodeId) || this._isInCache(nodeId.value));
        return nodeId;
    }
    constructNodeId(options) {
        function prepareName(browseName) {
            node_opcua_assert_1.assert(browseName instanceof node_opcua_data_model_1.QualifiedName);
            const m = browseName
                .name.toString()
                .replace(/[ ]/g, "")
                .replace(/(\<|\>)/g, "");
            return m;
        }
        let nodeId = options.nodeId;
        const nodeClass = options.nodeClass;
        if (!nodeId) {
            //    console.log("xx constructNodeId", options.browseName.toString());
            const parentInfo = this.findParentNodeId(options);
            if (parentInfo) {
                const [parentNodeId, linkName] = parentInfo;
                const name = prepareName(options.browseName);
                nodeId = null;
                if (parentNodeId.identifierType === node_opcua_nodeid_1.NodeId.NodeIdType.STRING) {
                    // combining string nodeId => not stored in chache
                    const childName = parentNodeId.value + exports.NamespaceOptions.nodeIdNameSeparator + name;
                    nodeId = new node_opcua_nodeid_1.NodeId(node_opcua_nodeid_1.NodeId.NodeIdType.STRING, childName, parentNodeId.namespace);
                    return nodeId;
                }
                else if (parentNodeId.identifierType === node_opcua_nodeid_1.NodeId.NodeIdType.NUMERIC) {
                    //
                    const baseNameInCache = this._reverseCache[parentNodeId.value];
                    if (baseNameInCache) {
                        const newName = baseNameInCache.name + linkName + "_" + name;
                        const nodeIdValueInCache = this._cache[newName];
                        if (nodeIdValueInCache) {
                            return new node_opcua_nodeid_1.NodeId(node_opcua_nodeid_1.NodeIdType.NUMERIC, nodeIdValueInCache, this.namespaceIndex);
                        }
                        else {
                            return this._getOrCreateFromName(newName, nodeClass);
                        }
                    }
                }
                // }} has parent ...
            }
            else {
                const isRootType = options.nodeClass === node_opcua_data_model_1.NodeClass.DataType ||
                    options.nodeClass === node_opcua_data_model_1.NodeClass.ObjectType ||
                    options.nodeClass === node_opcua_data_model_1.NodeClass.ReferenceType ||
                    options.nodeClass === node_opcua_data_model_1.NodeClass.VariableType;
                // try to find
                if (isRootType) {
                    const baseName = options.browseName.name.toString();
                    return this._getOrCreateFromName(baseName, nodeClass);
                }
            }
        }
        else if (typeof nodeId === "string") {
            if (this.namespaceIndex !== 0) {
                if (nodeId.match(regExp2)) {
                    // nothing
                }
                else if (nodeId.match(regExp1)) {
                    nodeId = "ns=" + this.namespaceIndex + ";" + nodeId;
                }
                else {
                    nodeId = this._getOrCreateFromName(nodeId, nodeClass);
                }
            }
        }
        nodeId = nodeId || this.buildNewNodeId();
        if (nodeId instanceof node_opcua_nodeid_1.NodeId) {
            node_opcua_assert_1.assert(nodeId.namespace === this.namespaceIndex);
            return nodeId;
        }
        nodeId = node_opcua_nodeid_1.resolveNodeId(nodeId);
        node_opcua_assert_1.assert(nodeId.namespace === this.namespaceIndex);
        return nodeId;
    }
    findParentNodeId(options) {
        if (!options.references) {
            return null;
        }
        for (const ref of options.references) {
            ref._referenceType = this.addressSpace.findReferenceType(ref.referenceType);
            /* istanbul ignore next */
            if (!ref._referenceType) {
                throw new Error("Cannot find referenceType " + JSON.stringify(ref));
            }
            ref.referenceType = ref._referenceType.nodeId;
        }
        // find HasComponent, or has Property reverse
        return _identifyParentInReference(options.references);
    }
    _addInCache(name, nodeIdValue, nodeClass) {
        node_opcua_assert_1.assert(!name.includes(":"), "Alias name should not contain special characters");
        node_opcua_assert_1.assert(typeof name === "string" && name[0] !== "[");
        if (this._isInCache(nodeIdValue) || this._cache[name]) {
            throw new Error("Already in Cache !" + name + " " + nodeIdValue + " = " + this._cache[name]);
        }
        this._cache[name] = nodeIdValue;
        this._reverseCache[nodeIdValue] = { name, nodeClass };
    }
    _isInCache(nodeIdValue) {
        return this._reverseCache[nodeIdValue] ? true : false;
    }
    _getOrCreateFromName(aliasName, nodeClass) {
        node_opcua_assert_1.assert(isValidNodeClass(nodeClass), "invalid node class " + nodeClass);
        node_opcua_assert_1.assert(!aliasName.includes(":"), "Alias name should not contain special characters");
        if (this._cache[aliasName]) {
            return new node_opcua_nodeid_1.NodeId(node_opcua_nodeid_1.NodeIdType.NUMERIC, this._cache[aliasName], this.namespaceIndex);
        }
        else {
            const nodeIdResult = this.buildNewNodeId();
            this._addInCache(aliasName, nodeIdResult.value, nodeClass);
            return nodeIdResult;
        }
    }
}
exports.NodeIdManager = NodeIdManager;
//# sourceMappingURL=nodeid_manager.js.map