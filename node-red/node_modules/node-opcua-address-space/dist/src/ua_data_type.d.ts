import { NodeClass } from "node-opcua-data-model";
import { AttributeIds } from "node-opcua-data-model";
import { DataValue } from "node-opcua-data-value";
import { ExtensionObject } from "node-opcua-extension-object";
import { ExpandedNodeId, NodeId } from "node-opcua-nodeid";
import { DataTypeDefinition } from "node-opcua-types";
import { DataType } from "node-opcua-variant";
import { SessionContext, UADataType as UADataTypePublic } from "../source";
import { BaseNode } from "./base_node";
import { ToStringOption } from "./base_node_private";
import * as tools from "./tool_isSupertypeOf";
import { UAObject } from "./ua_object";
import { StructuredTypeSchema } from "node-opcua-factory";
export declare type ExtensionObjectConstructor = new (options: any) => ExtensionObject;
export interface ExtensionObjectConstructorFuncWithSchema extends ExtensionObjectConstructor {
    schema: StructuredTypeSchema;
    possibleFields: string[];
    encodingDefaultBinary: ExpandedNodeId;
    encodingDefaultXml: ExpandedNodeId;
}
export interface UADataType {
    _extensionObjectConstructor: ExtensionObjectConstructorFuncWithSchema;
}
export interface IEnumItem {
    name: string;
    value: number;
}
export interface EnumerationInfo {
    nameIndex: {
        [id: string]: IEnumItem;
    };
    valueIndex: {
        [id: number]: IEnumItem;
    };
}
export declare class UADataType extends BaseNode implements UADataTypePublic {
    readonly nodeClass = NodeClass.DataType;
    readonly definitionName: string;
    readonly symbolicName: string;
    /**
     * returns true if this is a super type of baseType
     *
     * @example
     *
     *    var dataTypeDouble = addressSpace.findDataType("Double");
     *    var dataTypeNumber = addressSpace.findDataType("Number");
     *    assert(dataTypeDouble.isSupertypeOf(dataTypeNumber));
     *    assert(!dataTypeNumber.isSupertypeOf(dataTypeDouble));
     *
     */
    get subtypeOf(): NodeId | null;
    get subtypeOfObj(): UADataTypePublic | null;
    isSupertypeOf: tools.IsSupertypeOfFunc<UADataTypePublic>;
    readonly isAbstract: boolean;
    private enumStrings?;
    private enumValues?;
    private $definition?;
    constructor(options: any);
    get basicDataType(): DataType;
    readAttribute(context: SessionContext | null, attributeId: AttributeIds): DataValue;
    getEncodingDefinition(encoding_name: string): string | null;
    getEncodingNode(encoding_name: string): UAObject | null;
    getEncodingNodeId(encoding_name: string): ExpandedNodeId | null;
    /**
     * returns the encoding of this node's
     * TODO objects have 2 encodings : XML and Binaries
     */
    get binaryEncoding(): BaseNode | null;
    get binaryEncodingDefinition(): string | null;
    get binaryEncodingNodeId(): ExpandedNodeId | null;
    get xmlEncoding(): BaseNode | null;
    get xmlEncodingNodeId(): ExpandedNodeId | null;
    get xmlEncodingDefinition(): string | null;
    get jsonEncoding(): BaseNode | null;
    get jsonEncodingNodeId(): ExpandedNodeId | null;
    _getEnumerationInfo(): EnumerationInfo;
    _getDefinition(): DataTypeDefinition | null;
    install_extra_properties(): void;
    toString(): string;
}
export declare function DataType_toString(this: UADataType, options: ToStringOption): void;
