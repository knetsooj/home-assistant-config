"use strict";
/**
 * @module node-opcua-address-space
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionContext = void 0;
const node_opcua_assert_1 = require("node-opcua-assert");
// note : use specifically dist file to avoid modules that rely on fs
const node_opcua_crypto_1 = require("node-opcua-crypto");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_types_1 = require("node-opcua-types");
function getUserName(userIdentityToken) {
    if (userIdentityToken instanceof node_opcua_types_1.AnonymousIdentityToken) {
        return "anonymous";
    }
    if (userIdentityToken instanceof node_opcua_types_1.X509IdentityToken) {
        const certInfo = node_opcua_crypto_1.exploreCertificate(userIdentityToken.certificateData);
        const userName = certInfo.tbsCertificate.subject.commonName || "";
        if (typeof userName !== "string") {
            throw new Error("Invalid username");
        }
        return userName;
    }
    if (userIdentityToken instanceof node_opcua_types_1.UserNameIdentityToken) {
        if (userIdentityToken.policyId === "anonymous") {
            return "anonymous";
        }
        node_opcua_assert_1.assert(userIdentityToken.hasOwnProperty("userName"));
        return userIdentityToken.userName;
    }
    throw new Error("Invalid user identity token");
}
function hasOneRoleDenied(permission, roles) {
    for (const role of roles) {
        const str = "!" + role;
        if (permission.findIndex((x) => x === str) >= 0) {
            return true; // user is explicitly denied
        }
    }
    return false;
}
function hasOneRoleAllowed(permission, roles) {
    for (const role of roles) {
        const str = role;
        if (permission.findIndex((x) => x === str) >= 0) {
            return true; // user is explicitly denied
        }
    }
    return false;
}
class SessionContext {
    constructor(options) {
        this.continuationPoints = {};
        options = options || {};
        this.session = options.session;
        this.object = options.object;
        this.server = options.server;
        this.currentTime = undefined;
    }
    /**
     * getCurrentUserRole
     *
     * guest   => anonymous user (unauthenticated)
     * default => default authenticated user
     *
     */
    getCurrentUserRole() {
        if (!this.session) {
            return "default";
        }
        node_opcua_assert_1.assert(this.session != null, "expecting a session");
        const userIdentityToken = this.session.userIdentityToken;
        if (!userIdentityToken) {
            throw new Error("session object must provide a userIdentityToken");
        }
        const username = getUserName(userIdentityToken);
        if (username === "anonymous") {
            return "guest";
        }
        if (!this.server || !this.server.userManager) {
            return "default";
        }
        node_opcua_assert_1.assert(this.server != null, "expecting a server");
        if (typeof this.server.userManager.getUserRole !== "function") {
            return "default";
        }
        return this.server.userManager.getUserRole(username);
    }
    /**
     * @method checkPermission
     * @param node
     * @param action
     * @return {Boolean}
     */
    checkPermission(node, action) {
        // tslint:disable:no-bitwise
        const lNode = node;
        node_opcua_assert_1.assert(node_opcua_data_model_1.AccessLevelFlag.hasOwnProperty(action));
        const actionFlag = node_opcua_data_model_1.makeAccessLevelFlag(action);
        if (!lNode._permissions) {
            return (lNode.userAccessLevel & actionFlag) === actionFlag;
        }
        const permission = lNode._permissions[action];
        if (!permission) {
            return (lNode.userAccessLevel & actionFlag) === actionFlag;
        }
        const userRole = this.getCurrentUserRole();
        if (userRole === "default") {
            return (lNode.userAccessLevel & actionFlag) === actionFlag;
        }
        const roles = userRole.split(";");
        if (permission[0] === "*") {
            // accept all except...
            return !hasOneRoleDenied(permission, roles);
        }
        else {
            // deny a
            return hasOneRoleAllowed(permission, roles) && !hasOneRoleDenied(permission, roles);
        }
    }
}
exports.SessionContext = SessionContext;
SessionContext.defaultContext = new SessionContext({});
//# sourceMappingURL=session_context.js.map