"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeCrawler = void 0;
const chalk = require("chalk");
const async = require("async");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_crawler_base_1 = require("./node_crawler_base");
const cache_node_1 = require("./cache_node");
const private_1 = require("./private");
const node_opcua_utils_1 = require("node-opcua-utils");
const debugLog = node_opcua_debug_1.make_debugLog(__filename);
const doDebug = node_opcua_debug_1.checkDebugFlag(__filename);
class NodeCrawler extends node_crawler_base_1.NodeCrawlerBase {
    read(nodeId, callback) {
        /* istanbul ignore next */
        if (!callback) {
            throw new Error("Invalid Error");
        }
        try {
            nodeId = node_opcua_nodeid_1.resolveNodeId(nodeId);
        } /* istanbul ignore next */
        catch (err) {
            return callback(err);
        }
        const key = nodeId.toString();
        // check if object has already been crawled
        if (this._objMap.hasOwnProperty(key)) {
            const object = this._objMap[key];
            return callback(null, object);
        }
        const userData = {
            onBrowse: node_crawler_base_1.NodeCrawlerBase.follow
        };
        this.crawl(nodeId, userData, (err) => {
            /* istanbul ignore next */
            if (err) {
                return callback(err);
            }
            /* istanbul ignore else */
            if (this._objectCache.hasOwnProperty(key)) {
                const cacheNode = this._objectCache[key];
                node_opcua_assert_1.assert(cacheNode.browseName.name !== "pending");
                this.simplify_object(this._objMap, cacheNode, callback);
            }
            else {
                callback(new Error("Cannot find nodeId" + key));
            }
        });
    }
    simplify_object(objMap, object, finalCallback) {
        node_opcua_assert_1.assert(typeof finalCallback === "function");
        const queue = async.queue((task, innerCallback) => {
            setImmediate(() => {
                node_opcua_assert_1.assert(typeof task.func === "function");
                task.func(task, innerCallback);
            });
        }, 1);
        // tslint:disable:no-empty
        this._add_for_reconstruction(queue, objMap, object, () => { });
        const key1 = object.nodeId.toString();
        queue.drain(() => {
            const object1 = this._objMap[key1];
            private_1.remove_cycle(object1, finalCallback);
        });
    }
    _add_for_reconstruction(queue, objMap, object, extraFunc) {
        node_opcua_assert_1.assert(typeof extraFunc === "function");
        node_opcua_assert_1.assert(typeof object.nodeId.toString() === "string");
        const task = {
            data: object,
            func: (data, callback) => {
                this._reconstruct_manageable_object(queue, objMap, object, (err, obj) => {
                    extraFunc(err, obj);
                    callback(err || undefined);
                });
            }
        };
        queue.push(task);
    }
    _reconstruct_manageable_object(queue, objMap, object, callback) {
        node_opcua_assert_1.assert(typeof callback === "function");
        node_opcua_assert_1.assert(object);
        node_opcua_assert_1.assert(object.nodeId);
        const key2 = object.nodeId.toString();
        if (objMap.hasOwnProperty(key2)) {
            return callback(null, objMap[key2]);
        }
        /* reconstruct a more manageable object
         * var obj = {
         *    browseName: "Objects",
         *    organizes : [
         *       {
         *            browseName: "Server",
         *            hasComponent: [
         *            ]
         *            hasProperty: [
         *            ]
         *       }
         *    ]
         * }
         */
        const obj = {
            browseName: object.browseName.name,
            nodeId: object.nodeId.toString()
        };
        // Append nodeClass
        if (object.nodeClass) {
            obj.nodeClass = object.nodeClass.toString();
        }
        if (object instanceof cache_node_1.CacheNodeVariable || object instanceof cache_node_1.CacheNodeVariableType) {
            if (object.dataType) {
                obj.dataType = object.dataType.toJSON();
                // xx obj.dataTypeName = object.dataTypeName;
            }
            if (object.dataValue) {
                obj.dataValue = object.dataValue.toJSON();
            }
        }
        objMap[key2] = obj;
        const referenceMap = obj;
        object.references = object.references || [];
        object.references.map((ref) => {
            node_opcua_assert_1.assert(ref);
            const refIndex = ref.referenceTypeId.toString();
            const referenceType = this._objectCache[refIndex];
            /* istanbul ignore else */
            if (!referenceType) {
                debugLog(chalk.red("Unknown reference type " + refIndex));
                // debugLog(util.inspect(object, { colors: true, depth: 10 }));
                // console.log(chalk.red("Unknown reference type " + refIndex));
                // console.log(util.inspect(ref, { colors: true, depth: 10 }));
            }
            const reference = this._objectCache[ref.nodeId.toString()];
            /* istanbul ignore else */
            if (!reference) {
                debugLog(ref.nodeId.toString(), "bn=", ref.browseName.toString(), "class =", ref.nodeClass.toString(), ref.typeDefinition.toString());
                debugLog("#_reconstruct_manageable_object: Cannot find reference", ref.nodeId.toString(), "in cache");
            }
            if (reference) {
                // Extract nodeClass so it can be appended
                reference.nodeClass = ref.$nodeClass;
            }
            if (referenceType) {
                const refName = node_opcua_utils_1.lowerFirstLetter(referenceType.browseName.name);
                if (refName === "hasTypeDefinition") {
                    obj.typeDefinition = reference.browseName.name;
                }
                else {
                    if (!referenceMap[refName]) {
                        referenceMap[refName] = [];
                    }
                    if (!reference.nodeId) {
                        // tslint:disable-next-line: no-console
                        console.log("node id ", reference.toString());
                    }
                    this._add_for_reconstruction(queue, objMap, reference, (err, mObject) => {
                        if (!err) {
                            referenceMap[refName].push(mObject);
                        }
                    });
                }
            }
        });
        callback(null, obj);
    }
}
exports.NodeCrawler = NodeCrawler;
// tslint:disable:no-var-requires
// tslint:disable:max-line-length
const thenify = require("thenify");
NodeCrawler.prototype.read = thenify.withCallback(NodeCrawler.prototype.read);
//# sourceMappingURL=node_crawler.js.map