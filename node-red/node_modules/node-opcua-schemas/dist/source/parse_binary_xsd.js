"use strict";
/**
 * @module node-opcua-schemas
 */
// tslint:disable:no-console
// tslint:disable:object-literal-sort-keys
// tslint:disable:no-empty
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseBinaryXSDAsync = exports.parseBinaryXSD = exports.TypeDictionary = void 0;
const chalk = require("chalk");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_factory_1 = require("node-opcua-factory");
const node_opcua_xml2json_1 = require("node-opcua-xml2json");
const tools_1 = require("./tools");
const doDebug = node_opcua_debug_1.checkDebugFlag(__filename);
const debugLog = node_opcua_debug_1.make_debugLog(__filename);
function w(s, l) {
    return (s + "                                                    ").substr(0, l);
}
const predefinedType = {
    "opc:Bit": 1,
    "opc:Boolean": 1,
    "opc:Byte": 1,
    "opc:ByteString": 1,
    "opc:Char": 1,
    "opc:CharArray": 1,
    "opc:DateTime": 1,
    "opc:Double": 1,
    "opc:Float": 1,
    "opc:Guid": 1,
    "opc:Int16": 1,
    "opc:Int32": 1,
    "opc:Int64": 1,
    "opc:SByte": 1,
    "opc:String": 1,
    "opc:UInt16": 1,
    "opc:UInt32": 1,
    "opc:UInt64": 1,
    "ua:ByteStringNodeId": 1,
    "ua:DataValue": 1,
    "ua:DiagnosticInfo": 1,
    "ua:ExpandedNodeId": 1,
    "ua:ExtensionObject": 1,
    "ua:FourByteNodeId": 1,
    "ua:GuidNodeId": 1,
    "ua:LocalizedText": 1,
    "ua:NodeId": 1,
    "ua:NodeIdType": 1,
    "ua:NumericNodeId": 1,
    "ua:QualifiedName": 1,
    "ua:StatusCode": 1,
    "ua:StringNodeId": 1,
    "ua:TwoByteNodeId": 1,
    "ua:Variant": 1,
    "ua:XmlElement": 1
};
const found = {};
function resolveType(typeDictionary, typeName) {
    const namespace = typeName.split(":")[0];
    if (predefinedType[typeName]) {
        return;
    }
    if (!found[typeName]) {
        found[typeName] = typeName;
    }
    if (namespace === "ua") {
    }
}
class TypeDictionary {
    constructor() {
        this.targetNamespace = "";
        this.imports = [];
        this.structuredTypesRaw = [];
        this.enumeratedTypesRaw = [];
        this.structuredTypesRawMap = {};
    }
    addRaw(structuredType) {
        this.structuredTypesRaw.push(structuredType);
        this.structuredTypesRawMap[structuredType.name] = structuredType;
    }
    getStructuredTypesRawByName(name) {
        return this.structuredTypesRawMap[name];
    }
}
exports.TypeDictionary = TypeDictionary;
/* tslint:disable:object-literal-shorthand */
const state0 = {
    init: () => {
        const a = 1;
    },
    parser: {
        TypeDictionary: {
            init: function (name, attributes) {
                this.typeDictionary = this.engine.typeDictionary;
                this.typeDictionary.defaultByteOrder = attributes.DefaultByteOrder;
                this.typeDictionary.targetNamespace = attributes.TargetNamespace;
            },
            parser: {
                Import: {
                    init: function (name, attributes) {
                        this.parent.typeDictionary.imports.push(attributes.Namespace);
                    },
                    finish: function () {
                        // _register_namespace_uri(this.text);
                        // istanbul ignore next
                        if (doDebug) {
                            debugLog("Import NameSpace = ", this.attrs.Namespace, " Location", this.attrs.Location);
                        }
                    }
                },
                EnumeratedType: {
                    init: function () {
                        this.typescriptDefinition = "";
                        // istanbul ignore next
                        if (doDebug) {
                            debugLog(chalk.cyan("EnumeratedType Name="), w(this.attrs.Name, 40), "LengthInBits=", this.attrs.LengthInBits);
                        }
                        this.enumeratedType = {
                            enumeratedValues: {},
                            lengthInBits: parseInt(this.attrs.LengthInBits, 10),
                            name: this.attrs.Name
                        };
                        this.typescriptDefinition += `enum ${this.enumeratedType.name} {`;
                    },
                    parser: {
                        Documentation: {
                            finish: function () {
                                this.parent.enumeratedType.documentation = this.text;
                            }
                        },
                        EnumeratedValue: {
                            finish: function () {
                                // istanbul ignore next
                                if (doDebug) {
                                    debugLog(" EnumeratedValue Name=", w(this.attrs.Name, 40), " Value=", this.attrs.Value);
                                }
                                const key = this.attrs.Name;
                                const value = parseInt(this.attrs.Value, 10);
                                const _enum = this.parent.enumeratedType.enumeratedValues;
                                _enum[_enum[key] = value] = key;
                                this.parent.typescriptDefinition += `\n  ${key} = ${value},`;
                            }
                        }
                    },
                    finish: function () {
                        this.typescriptDefinition += `\n}`;
                        this.parent.typeDictionary.enumeratedTypesRaw[this.attrs.Name] = this.enumeratedType;
                        // istanbul ignore next
                        if (doDebug) {
                            debugLog(" this.typescriptDefinition  = ", this.typescriptDefinition);
                        }
                    }
                },
                StructuredType: {
                    init: function () {
                        // istanbul ignore next
                        if (doDebug) {
                            debugLog(chalk.cyan("StructureType Name="), chalk.green(this.attrs.Name), " BaseType=", this.attrs.BaseType);
                        }
                        const baseType = this.attrs.BaseType;
                        const base = this.parent.typeDictionary.structuredTypesRawMap[baseType];
                        const structuredType = {
                            name: this.attrs.Name,
                            baseType: baseType,
                            fields: []
                        };
                        if (base) {
                            structuredType.base = base;
                        }
                        this.structuredType = structuredType;
                    },
                    parser: {
                        Field: {
                            finish: function () {
                                if (this.attrs.SourceType) {
                                    // ignore  this field, This is a repetition of the base type field with same name
                                    return;
                                }
                                // istanbul ignore next
                                if (doDebug) {
                                    debugLog(chalk.yellow(" field Name="), w(this.attrs.Name, 40), chalk.yellow(" typeName="), w(this.attrs.TypeName, 40), this.attrs.LengthField ? chalk.yellow(" lengthField= ") + w(this.attrs.LengthField, 40) : "", this.attrs.SwitchField ? chalk.yellow(" SwitchField= ") + w(this.attrs.SwitchField, 40) : "", this.attrs.SwitchValue !== undefined ? chalk.yellow(" SwitchValue= ") + w(this.attrs.SwitchValue, 40) : "");
                                }
                                resolveType(this.parent.typeDictionary, this.attrs.TypeName);
                                const field = {
                                    name: this.attrs.Name,
                                    fieldType: this.attrs.TypeName
                                };
                                const structuredType = this.parent.structuredType;
                                if (field.fieldType === "opc:Bit") {
                                    // do something to collect bits but ignore them as field
                                    structuredType.bitFields = structuredType.bitFields || [];
                                    const length = this.attrs.Length || 1;
                                    structuredType.bitFields.push({ name: field.name, length });
                                    return;
                                }
                                if (this.attrs.LengthField) {
                                    field.isArray = true;
                                    const n = structuredType.fields.length - 1;
                                    structuredType.fields[n] = field;
                                }
                                else {
                                    structuredType.fields.push(field);
                                }
                                if (this.attrs.SwitchField) {
                                    // field is optional and can be omitted
                                    const switchField = this.attrs.SwitchField;
                                    if (this.attrs.SwitchValue) {
                                        // we are in a union
                                        field.switchValue = parseInt(this.attrs.SwitchValue, 10);
                                        // istanbul ignore next
                                        if (doDebug) {
                                            debugLog("field", field.name, " is part of a union  => ", switchField, " value #", field.switchValue);
                                        }
                                    }
                                    else {
                                        field.switchBit = structuredType.bitFields ?
                                            structuredType.bitFields.findIndex((x) => x.name === switchField) : -2;
                                        // istanbul ignore next
                                        if (doDebug) {
                                            debugLog("field", field.name, " is optional => ", switchField, "bit #", field.switchBit);
                                        }
                                    }
                                }
                            }
                        }
                    },
                    finish: function () {
                        node_opcua_assert_1.default(this.attrs.Name === this.structuredType.name);
                        this.parent.typeDictionary.addRaw(this.structuredType);
                    }
                }
            }
        }
    }
};
function parseBinaryXSD(xmlString, idProvider, dataTypeFactory, callback) {
    const parser = new node_opcua_xml2json_1.Xml2Json(state0);
    const typeDictionary = new TypeDictionary();
    parser.typeDictionary = typeDictionary;
    parser.parseString(xmlString, (err) => {
        // resolve and prepare enumerations
        for (const key in typeDictionary.enumeratedTypesRaw) {
            if (!typeDictionary.enumeratedTypesRaw.hasOwnProperty(key)) {
                continue;
            }
            const enumeratedType = typeDictionary.enumeratedTypesRaw[key];
            const e = new node_opcua_factory_1.EnumerationDefinitionSchema({
                lengthInBits: enumeratedType.lengthInBits || 32,
                enumValues: enumeratedType.enumeratedValues,
                name: key
            });
            dataTypeFactory.registerEnumeration(e);
        }
        // istanbul ignore next
        if (doDebug) {
            debugLog("------------------------------- Resolving complex Type");
            typeDictionary.structuredTypesRaw.map((x) => debugLog(x.name));
        }
        // create area in navigation order
        function createExplorationOrder() {
            const array = [];
            const map = {};
            function visitStructure(structuredType) {
                if (!structuredType) {
                    return;
                }
                if (map[structuredType.name]) {
                    return;
                }
                if (structuredType.baseType) {
                    const base = typeDictionary.getStructuredTypesRawByName(structuredType.baseType);
                    if (base) {
                        visitStructure(base);
                    }
                }
                for (const f of structuredType.fields) {
                    const fieldType = f.fieldType.split(":")[1];
                    const s = typeDictionary.getStructuredTypesRawByName(fieldType);
                    if (s !== structuredType && s) {
                        visitStructure(s);
                    }
                    else {
                        map[fieldType] = "1";
                    }
                }
                if (!map[structuredType.name]) {
                    map[structuredType.name] = 1;
                    array.push(structuredType);
                }
            }
            for (const structuredType of typeDictionary.structuredTypesRaw) {
                visitStructure(structuredType);
            }
            return array;
        }
        // resolve complex types
        const schemaInVisitingOrder = createExplorationOrder();
        for (const structuredType of schemaInVisitingOrder) {
            debugLog("processing ", chalk.cyan(structuredType.name));
            tools_1.getOrCreateStructuredTypeSchema(structuredType.name, typeDictionary, dataTypeFactory, idProvider);
        }
        callback(err);
    });
}
exports.parseBinaryXSD = parseBinaryXSD;
function parseBinaryXSDAsync(xmlString, idProvider, dataTypeFactory) {
    return __awaiter(this, void 0, void 0, function* () {
        debugLog("parseBinaryXSDAsync");
        yield new Promise((resolve, reject) => {
            parseBinaryXSD(xmlString, idProvider, dataTypeFactory, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    });
}
exports.parseBinaryXSDAsync = parseBinaryXSDAsync;
//# sourceMappingURL=parse_binary_xsd.js.map